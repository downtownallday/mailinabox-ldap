#!/bin/bash

# Set up oauth shared secrets
#   JWT signing keys
#   client password
#
# This script must be run after managment's python3 isloated
# environment is created, but before the management daemon starts.
#
# Signing keys may be regenerated/rotated at any time by running this
# script. New keys require a restart of the management daemon but not
# dovecot
#

source setup/functions.sh
source /etc/mailinabox.conf # load global vars

PYTHON="/usr/local/lib/mailinabox/env/bin/python3"
STORAGE_OAUTH_ROOT="$STORAGE_ROOT/authorization_server"
CLIENT_CONFIG="/var/lib/mailinabox/mgmt_oauth_config.json"

hmac_bits=384

#
# generate an oauth client configuration
#
# client_id: the id of the oauth client (management console)
#
# client_password: the password the client uses to authenticate with
# the oauth server to obtain tokens, get tokeninfo, etc. Since the
# server is local, it will obtain this shared secret from the same
# file.
#
# oauth_login_url: endpoint where the user can interactively obtain
# authorization (login into the oauth server)
#
# oauth_token_url: endpoint where the management daemon can obtain the
# user's access token from the oauth server
#
# authorize_url: the managment daemon endpoint that handles the
# redirect after oauth server login
#
mkdir -p $(dirname "$CLIENT_CONFIG")
if [ ! -e "$CLIENT_CONFIG" ]; then
    cat > "$CLIENT_CONFIG" <<EOF
{   
   "client_id": "miabldap",
   "client_password": "$(generate_password 32)",
   "oauth_login_url": "https://${PRIMARY_HOSTNAME}/auth/oauth/authorize",
   "oauth_token_url": "http://localhost:10222/oauth/token",
   "oauth_revoke_url": "http://localhost:10222/oauth/revoke",
   "authorize_url": "https://${PRIMARY_HOSTNAME}/admin/oauth-authorization",
   "allow_api_key_login": false
}
EOF
    chmod 600 "$CLIENT_CONFIG"
fi


# generate a RFC7515 JSON Web Key for signing JWTs. we choose the
# "HSnnn" algorithm (HMAC using SHA-nnn) because HMAC's are small
# and fast, plus dovecot is local so it's easy to share the secret

# use unix time as the key-id
kid=$(date +%s)

# generate the key
k_b64_compact=$($PYTHON -c "import authlib.jose as jose; k=jose.JsonWebKey().generate_key('oct',${hmac_bits},is_private=True); print(k['k'])")

# authlib key generation uses the compact url-safe base64
# variant. dovecot (as of 2.3.11) doesn't accept it, so get the
# standard base64 representation for dovecot's validation dictionary
k_b64=$($PYTHON -c "from authlib.common.encoding import urlsafe_b64decode; import base64; raw=urlsafe_b64decode(b'$k_b64_compact'); print(base64.b64encode(raw).decode('utf-8'));")

# create the "keys" directory
mkdir -p "$STORAGE_OAUTH_ROOT/keys"
    
# Set the umask so the key file is never world-readable
(umask 037;
 cat > "$STORAGE_OAUTH_ROOT/keys/jwt_signing_key-$kid.json" <<EOF
{
  "kty": "oct",
  "alg": "HS${hmac_bits}",
  "kid": "$kid",
  "k": "$k_b64_compact"
}
EOF
)

# Symlink to the active key
ln -sf jwt_signing_key-$kid.json "$STORAGE_OAUTH_ROOT/keys/jwt_signing_key.json"

# Add the validation key to dovecot's OAuth JWT validation dictionary
azp="roundcube"  # "authorized party" (must match "azp" in token claims)
mkdir -p "$STORAGE_OAUTH_ROOT/dovecot/$azp/HS${hmac_bits}"
echo -n "$k_b64" > "$STORAGE_OAUTH_ROOT/dovecot/$azp/HS${hmac_bits}/$kid"

# Age off dovecot validation keys older than 10 days. A new
# validation/signing key was just created and new tokens will be
# singed by it. We want to honor tokens that have already been created
# with older keys, but not forever. It's safer to put a time boundry
# on the rotated keys.

find "$STORAGE_OAUTH_ROOT/dovecot" -type f -mtime 10 -exec rm {} \;

#
# delete the cached Flask session "salt" so new salt is generated by
# daemon_oauth.py. This will cause all users to be logged out of the
# oauth server.
#
rm -f /var/lib/mailinabox/session_salt.txt
